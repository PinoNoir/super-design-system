import { Controls, Description, Meta, Story, Title, Canvas } from '@storybook/addon-docs/blocks';
import * as TableStories from './Table.stories';

<Meta of={TableStories} />

<Title />

<Description />

A powerful, feature-rich table component that supports sorting, pagination, row selection, drag-and-drop, server-side data handling, and custom row rendering with seamless checkbox integration.

### Component API

<Controls />

```tsx
import { Table, useRowSelection } from '@stretto/cds-ui';

const MyComponent = () => {
  const data = [
    { id: '1', name: 'John Doe', age: 30 },
    { id: '2', name: 'Jane Smith', age: 25 },
  ];

  // Use row selection hook for selection state
  const tableState = useRowSelection({ multipleSelect: true });

  const columns = [
    {
      key: 'name', // Must match data property name for sorting
      header: 'Name',
      width: 120,
      isSortable: true,
      render: (data: TableRowData) => data.name, // Must use the render prop to display the data
    },
    {
      key: 'age', // Must match data property name for sorting
      header: 'Age',
      width: 120,
      isSortable: true,
      render: (data: TableRowData) => data.age, // Must use the render prop to display the data
    },
  ];

  return (
    <Table
      data={data}
      columns={columns}
      selectedRowIds={tableState.selectedRowIds}
      onSelectionChange={tableState.handleSelectionChange}
      getIsRowSelected={tableState.isRowSelected}
    />
  );
};
```

# useDataSort Hook

A custom React hook for sorting data with intelligent comparison logic and flexible sort direction management. This hook provides robust sorting capabilities that work with multiple data types including strings, numbers, dates, and booleans.

## Overview

The `useDataSort` hook manages sorting state and provides a sorting function that can be applied to any dataset. It features intelligent type detection, null handling, and customizable sort behavior with toggle functionality.

## API Reference

### Parameters

| Parameter        | Type     | Default | Description             |
| ---------------- | -------- | ------- | ----------------------- |
| `defaultSortKey` | `string` | `''`    | Initial sort column key |

### Returns

The hook returns an object with the following properties:

| Property           | Type                             | Description                                                       |
| ------------------ | -------------------------------- | ----------------------------------------------------------------- |
| `sortedData`       | `<T>(data: T[]) => T[]`          | Function to sort an array of data based on current sort settings  |
| `handleSort`       | `(key: string) => void`          | Function to handle column sort clicks with toggle behavior        |
| `setSortDirection` | `(direction: SortOrder) => void` | Function to manually set sort direction                           |
| `sortKey`          | `string`                         | Current column being sorted                                       |
| `sortDirection`    | `SortOrder`                      | Current sort direction (`'ascending'`, `'descending'`, or `none`) |
| `hasSorted`        | `boolean`                        | Whether any sorting has been applied                              |

### Types

```tsx
type SortOrder = 'ascending' | 'descending' | 'none';

interface SortableData {
  [key: string]: any;
}
```

## Features

### Type Detection

- **Automatic type recognition**: Detects strings, numbers, dates, booleans
- **Numeric string handling**: Properly sorts "10" vs "2" numerically
- **Date parsing**: Handles both Date objects and ISO date strings
- **Mixed type support**: Gracefully handles mixed data types

### Sort Behavior

- **Three-state toggle**: Ascending → Descending → Ascending
- **Column switching**: Resets to ascending when changing columns
- **Null handling**: Consistent null/undefined placement
- **No mutation**: Original data arrays are never modified

### Performance Optimized

- **Lazy sorting**: Only sorts when `hasSorted` is true
- **Memoized functions**: Callbacks are optimized with `useCallback`
- **Efficient comparison**: Type-specific comparison algorithms

## Basic Usage

```tsx
import { useDataSort } from '@stretto/cds-ui';

interface User {
  id: string;
  name: string;
  age: number;
  email: string;
  isActive: boolean;
  createdAt: Date;
}

const SortableUserTable: React.FC = () => {
  const users: User[] = [
    {
      id: '1',
      name: 'John Doe',
      age: 30,
      email: 'john@example.com',
      isActive: true,
      createdAt: new Date('2023-01-15'),
    },
    // ... more users
  ];

  const { sortedData, handleSort, sortKey, sortDirection } = useDataSort('name'); // Default sort by name

  const sortedUsers = sortedData(users);

  const getSortIcon = (columnKey: string) => {
    if (sortKey !== columnKey) return '↕️';
    return sortDirection === 'ascending' ? '↑' : '↓';
  };

  return (
    <table>
      <thead>
        <tr>
          <th onClick={() => handleSort('name')}>Name {getSortIcon('name')}</th>
          <th onClick={() => handleSort('age')}>Age {getSortIcon('age')}</th>
          <th onClick={() => handleSort('email')}>Email {getSortIcon('email')}</th>
          <th onClick={() => handleSort('isActive')}>Status {getSortIcon('isActive')}</th>
          <th onClick={() => handleSort('createdAt')}>Created {getSortIcon('createdAt')}</th>
        </tr>
      </thead>
      <tbody>
        {sortedUsers.map((user) => (
          <tr key={user.id}>
            <td>{user.name}</td>
            <td>{user.age}</td>
            <td>{user.email}</td>
            <td>{user.isActive ? 'Active' : 'Inactive'}</td>
            <td>{user.createdAt.toLocaleDateString()}</td>
          </tr>
        ))}
      </tbody>
    </table>
  );
};
```

## Advanced Usage

### With Table Component

```tsx
import { useDataSort, Table } from '@stretto/cds-ui';

const SortableTable: React.FC = () => {
  const { sortedData, handleSort, sortKey, sortDirection } = useDataSort();

  const sortedTableData = sortedData(originalData);

  const columns = [
    {
      key: 'name',
      header: 'Name',
      isSortable: true,
    },
    {
      key: 'age',
      header: 'Age',
      isSortable: true,
    },
    // ... more columns
  ];

  return (
    <Table
      data={sortedTableData}
      columns={columns}
      onSort={handleSort}
      sortKey={sortKey}
      sortDirection={sortDirection}
    />
  );
};
```

### With Search and Pagination

```tsx
const FullFeaturedTable: React.FC = () => {
  const { filterData, searchTerm, handleSearch } = useDataSearch();
  const { sortedData, handleSort, sortKey, sortDirection } = useDataSort();

  const processedData = useMemo(() => {
    // First filter, then sort
    const filtered = filterData(originalData);
    return sortedData(filtered);
  }, [filterData, sortedData, originalData]);

  return (
    <div>
      <input type="text" value={searchTerm} onChange={handleSearch} placeholder="Search..." />
      <Table
        data={processedData}
        columns={columns}
        onSort={handleSort}
        sortKey={sortKey}
        sortDirection={sortDirection}
        enablePagination
      />
    </div>
  );
};
```

### Manual Sort Control

```tsx
const ManualSortControl: React.FC = () => {
  const { sortedData, setSortDirection, sortKey, sortDirection } = useDataSort('name');

  const handleManualSort = (direction: SortOrder) => {
    setSortDirection(direction);
  };

  return (
    <div>
      <div className="sort-controls">
        <button onClick={() => handleManualSort('ascending')}>Sort Ascending</button>
        <button onClick={() => handleManualSort('descending')}>Sort Descending</button>
        <button onClick={() => handleManualSort(null)}>Clear Sort</button>
      </div>

      <div>
        Current: {sortKey} - {sortDirection || 'none'}
      </div>

      {/* Render sorted data */}
    </div>
  );
};
```

## Sorting Behavior

### Data Type Handling

| Type               | Behavior                       | Example                       |
| ------------------ | ------------------------------ | ----------------------------- |
| **String**         | Locale-aware, case-insensitive | "apple" < "Banana" < "cherry" |
| **Number**         | Numeric comparison             | 2 < 10 < 100                  |
| **Numeric String** | Parsed as numbers              | "2" < "10" < "100"            |
| **Date**           | Chronological order            | Earlier dates < Later dates   |
| **Date String**    | Parsed to Date objects         | "2023-01-01" < "2023-12-31"   |
| **Boolean**        | false < true                   | false < true                  |
| **Mixed Types**    | Type-specific handling         | Numbers before strings        |

### Null/Undefined Handling

```tsx
// Ascending order: valid values first, nulls last
[1, 2, 3, null, undefined][
  // Descending order: nulls first, valid values descending
  (null, undefined, 3, 2, 1)
];
```

### Sort Direction Toggle

```tsx
// Click sequence on same column:
// 1st click: ascending
// 2nd click: descending
// 3rd click: ascending (cycle repeats)

// Switching columns always starts with ascending
```

## Performance Considerations

- **Conditional sorting**: Only sorts when `hasSorted` is true
- **Property validation**: Checks for property existence before sorting
- **Memoized callbacks**: Functions are optimized with `useCallback`
- **Type-specific algorithms**: Uses optimal comparison for each data type
- **Immutable operations**: Creates new arrays without mutating originals

## TypeScript Support

The hook is fully typed and supports generic data types:

```tsx
interface Product {
  id: string;
  name: string;
  price: number;
  category: string;
  inStock: boolean;
}

const { sortedData } = useDataSort<Product>('name');

// TypeScript knows this returns Product[]
const sortedProducts: Product[] = sortedData(products);
```

## Migration Guide

### Breaking Changes from Previous Version

#### ❌ Removed: Data Parameter

**Before (v9.x):**

```tsx
const { sortedData } = useDataSort(data, 'name', searchTerm);
```

**After (v10.x):**

```tsx
const { sortedData } = useDataSort('name');
const sorted = sortedData(data);
```

#### ❌ Removed: Search Integration

**Before (v9.x):**

```tsx
const { sortedData } = useDataSort(data, 'name', searchTerm);
```

**After (v10.x):**

```tsx
// Use separate hooks and compose them
const { filterData } = useDataSearch();
const { sortedData } = useDataSort('name');

const processedData = sortedData(filterData(data));
```

#### ❌ Changed: Sort Direction Values

**Before (v9.x):**

```tsx
sortDirection: 'ascending' | 'descending' | null;
```

**After (v10.x):**

```tsx
sortDirection: 'ascending' | 'descending' | 'none';
```

#### ✅ New: hasSorted Property

**New in v10.x:**

```tsx
const { hasSorted } = useDataSort();
// Know if any sorting has been applied
```

#### ✅ Enhanced: Better Type Detection

**Improved in v10.x:**

- Better numeric string handling
- Enhanced date parsing
- Mixed type support

### Migration Steps

1. **Remove data and searchTerm parameters** from `useDataSort()` call
2. **Replace direct `sortedData` usage** with `sortedData(yourData)`
3. **Handle search separately** using `useDataSearch` hook
4. **Update sort direction checks** from `'none'` to `null`
5. **Compose hooks** for search + sort functionality

### Example Migration

**Before:**

```tsx
const MyComponent = ({ data }) => {
  const [searchTerm, setSearchTerm] = useState('');
  const { sortedData, handleSort, sortKey, sortDirection } = useDataSort(data, 'name', searchTerm);

  return (
    <div>
      <input value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} />
      <table>
        <thead>
          <tr>
            <th onClick={() => handleSort('name')}>
              Name {sortKey === 'name' && (sortDirection === 'ascending' ? '▲' : '▼')}
            </th>
          </tr>
        </thead>
        <tbody>
          {sortedData.map((item) => (
            <tr key={item.id}>
              <td>{item.name}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};
```

**After:**

```tsx
const MyComponent = ({ data }) => {
  const { filterData, searchTerm, handleSearch } = useDataSearch();
  const { sortedData, handleSort, sortKey, sortDirection } = useDataSort('name');

  const processedData = useMemo(() => {
    const filtered = filterData(data);
    return sortedData(filtered);
  }, [filterData, sortedData, data]);

  return (
    <div>
      <input value={searchTerm} onChange={handleSearch} />
      <table>
        <thead>
          <tr>
            <th onClick={() => handleSort('name')}>
              Name {sortKey === 'name' && (sortDirection === 'ascending' ? '▲' : '▼')}
            </th>
          </tr>
        </thead>
        <tbody>
          {processedData.map((item) => (
            <tr key={item.id}>
              <td>{item.name}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};
```
